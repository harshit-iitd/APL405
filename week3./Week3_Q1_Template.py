# -*- coding: utf-8 -*-
"""Week3_Q1_Template.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1EcIa-qvK_VPvhvFD7eqL7SLnsQAQplRJ
"""

import numpy as np
from scipy import optimize
import pandas as pd
from matplotlib import pyplot

class lr:
    # Data cleaning and finding the mean of the column titled "MaxTemp"
    def data_clean(self,data):
        # 'data' is a dataframe imported from '.csv' file using 'pandas'
        # Perform data cleaning steps sequentially as mentioned in assignment
        data.loc[data["RainTomorrow"]=="No","RainTomorrow"]=0
        data.loc[data["RainTomorrow"]=="Yes","RainTomorrow"]=1
        feature_values = data.iloc[:,:data.shape[1]-1].copy()
        predictions = data.iloc[:,data.shape[1]-1].copy()
        feature_values = feature_values.select_dtypes(exclude=['object'])
        a = feature_values.mean().copy()
        b = round(predictions.mean().copy())
        for i in range(0,feature_values.shape[1]):
            feature_values.iloc[feature_values.iloc[:,i].isnull().values,i] = a[i]
        predictions.iloc[predictions.isnull().values] = b
        Min = feature_values.min().copy()
        Max = feature_values.max().copy()
        feature_values = (feature_values-Min)/(Max-Min)
        mean = round(feature_values["MaxTemp"].mean(),3)  
        X = feature_values
        y = predictions
        y = y.astype('int8j0')
    
        return X, y, mean

class costing:
    # define the function needed to evaluate cost function
    # Input 'z' could be a scalar or a 1D vector
    def sigmoid(self,z):
        z = np.array(z)
        g = 1.0/(1+ np.exp(-z))
        
        return g
    
    def costFunctionReg(self,w,X,y,lambda_):
        m = X.shape[0]
        h = self.sigmoid(np.matmul(X,w))
        grad = np.matmul(np.transpose(h-y),X)
        a = np.ones(w.shape[0])
        a[0] = 0
        grad+= (lambda_*(w*a))
        grad = grad/m
        J = np.sum((-y*np.log(h)-((1-y)*np.log(1-h)))) +((lambda_/(2))*np.dot(w,w))
        J = J/m
        return J, grad
    
    def predict(self,w,X):
        p = np.round(self.sigmoid(np.matmul(X,w)))
        return p
    
    def minCostFun(self, w_ini, X_train, y_train, iters):
        # iters - Maximum no. of iterations; X_train - Numpy array
        lambda_ = 0.1     # Regularization parameter
        X_train = np.column_stack((np.ones(X_train.shape[0]),X_train))
        options = {'maxiter':iters}
        res = optimize.minimize(self.costFunctionReg,w_ini,
                                (X_train, y_train,lambda_),jac = True,method = 'TNC',options=options)
        
        w_opt = np.round(res.x,decimals = 4)
        y_pred = self.predict(w_opt,X_train)
        acrcy = round(sum(y_pred == y_train)*100/y_train.shape[0],3)
        return w_opt, acrcy
    
    def TestingAccu(self, w_opt, X_test, y_test):
        X_test = np.column_stack((np.ones(X_test.shape[0]),X_test))
        pred = self.predict(w_opt,X_test)
        
        acrcy_test = round(sum(pred == y_test)*100/y_test.shape[0],3)    # Testing set accuracy (in %) rounded off to 3 decimal places
        
        return acrcy_test
